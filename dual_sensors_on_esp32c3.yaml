# Uart2 numbers won't set, work in progress. Binary sensors and distance work as expected.
# Workaround: interchange uart ids set distances and time, and then change it back if you dont want to use the BT app.


esp32:
  board: esp32-c3-devkitm-1 #actual board is ESP32C3 Core LuatOS
  framework:
    type: esp-idf


esphome:
  name: esp32c3-5
  friendly_name: esp32c3-5
  includes:
    - LD2411s2.h
    - LD2411s.h
  platformio_options:
    board_build.flash_mode: dio #this board needs this line to boot
  on_boot:
    priority: 250
    then:
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0x73, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
          
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0x73, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]

uart:
  - id: uart_bus2
    tx_pin: 21
    rx_pin: 20
    baud_rate: 256000
    parity: NONE
    stop_bits: 1
  - id: uart_bus
    tx_pin: 0
    rx_pin: 1
    baud_rate: 256000
    parity: NONE
    stop_bits: 1

    
logger:
  baud_rate: 0
  logs:
    sensor: INFO

api:
  encryption:
    key: ""

ota:
  password: ""

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Esp32C3-5 Fallback Hotspot"
    password: ""

captive_portal:

sensor:
  - platform: custom
    lambda: |-
      auto my_sensor = new UARTSensor(id(uart_bus)); 
      App.register_component(my_sensor);
      return {my_sensor->distance_sensor, my_sensor->presence_sensor, my_sensor->motion_sensor, my_sensor->max_motion_sensor, my_sensor->min_motion_sensor, my_sensor->max_presence_sensor, my_sensor->min_presence_sensor, my_sensor->unocc_time_sensor};
    sensors:
      - name: "Distance"
        state_class: measurement
        id: distance_sensor
        unit_of_measurement: cm
      - id: presence_sensor
        name: "internal_presense_sensor_to_binary_template"
        internal: true
        on_value:
          - binary_sensor.template.publish:
              id: presence_template
              state: !lambda return x > 0;
      - id: motion_sensor
        name: "internal_motion_sensor_to_binary_template"
        internal: true
        on_value:
          - binary_sensor.template.publish:
              id: motion_template
              state: !lambda return x > 0;
      - name: "internal_max_motion"
        id: max_motion_sensor
        internal: true
        on_value:
          - number.set:
              id: maxmotion
              value: !lambda return x;
      - name: "internal_min_motion"
        id: min_motion_sensor
        internal: true
        on_value:
          - number.set:
              id: minmotion
              value: !lambda return x;
      - name: "internal_max_presence"
        id: max_presence_sensor
        internal: true
        on_value:
          - number.set:
              id: maxpresence
              value: !lambda return x;
      - name: "internal_min_presence"
        id: min_presence_sensor
        internal: true
        on_value:
          - number.set:
              id: minpresence
              value: !lambda return x;
      - name: "internal_unocc"
        id: unocc_time_sensor
        internal: true
        on_value:
          - number.set:
              id: unocc_time
              value: !lambda return x;

  - platform: custom
    lambda: |-
      auto my_sensor2 = new UARTSensor2(id(uart_bus2)); 
      App.register_component(my_sensor2);
      return {my_sensor2->distance_sensor2, my_sensor2->presence_sensor2, my_sensor2->motion_sensor2, my_sensor2->max_motion_sensor2, my_sensor2->min_motion_sensor2, my_sensor2->max_presence_sensor2, my_sensor2->min_presence_sensor2, my_sensor2->unocc_time_sensor2};
    sensors:
      - name: "Distance2"
        state_class: measurement
        id: distance_sensor2
        unit_of_measurement: cm
      - id: presence_sensor2
        name: "internal_presense_sensor_to_binary_template2"
        internal: true
        on_value:
          - binary_sensor.template.publish:
              id: presence_template2
              state: !lambda return x > 0;
      - id: motion_sensor2
        name: "internal_motion_sensor_to_binary_template2"
        internal: true
        on_value:
          - binary_sensor.template.publish:
              id: motion_template2
              state: !lambda return x > 0;
      - name: "internal_max_motion2"
        id: max_motion_sensor2
        internal: true
        on_value:
          - number.set:
              id: maxmotion2
              value: !lambda return x;
      - name: "internal_min_motion2"
        id: min_motion_sensor2
        internal: true
        on_value:
          - number.set:
              id: minmotion2
              value: !lambda return x;
      - name: "internal_max_presence2"
        id: max_presence_sensor2
        internal: true
        on_value:
          - number.set:
              id: maxpresence2
              value: !lambda return x;
      - name: "internal_min_presence2"
        id: min_presence_sensor2
        internal: true
        on_value:
          - number.set:
              id: minpresence2
              value: !lambda return x;
      - name: "internal_unocc2"
        id: unocc_time_sensor2
        internal: true
        on_value:
          - number.set:
              id: unocc_time2
              value: !lambda return x;


  - platform: uptime
    name: Uptime Sensor
    update_interval: 1s
    filters:
      - delta: 1%

number:
  - platform: template
    name: "Min Motion Distance"
    id: minmotion
    optimistic: true
    unit_of_measurement: cm
    min_value: 30
    max_value: 717
    step: 1
  - platform: template
    name: "Max Motion Distance"
    id: maxmotion
    optimistic: true
    unit_of_measurement: cm
    min_value: 30
    max_value: 717
    step: 1
  - platform: template
    name: "Min Presence Distance"
    id: minpresence
    optimistic: true
    unit_of_measurement: cm
    min_value: 30
    max_value: 425
    step: 1
  - platform: template
    name: "Max Presence Distance"
    id: maxpresence
    optimistic: true
    unit_of_measurement: cm
    min_value: 30
    max_value: 425
    step: 1
  - platform: template
    name: "Unoccupied Time"
    id: unocc_time
    optimistic: true
    unit_of_measurement: sec
    min_value: 0
    max_value: 6553
    step: 1

  - platform: template
    name: "Min Motion Distance2"
    id: minmotion2
    optimistic: true
    unit_of_measurement: cm
    min_value: 30
    max_value: 717
    step: 1
  - platform: template
    name: "Max Motion Distance2"
    id: maxmotion2
    optimistic: true
    unit_of_measurement: cm
    min_value: 30
    max_value: 717
    step: 1
  - platform: template
    name: "Min Presence Distance2"
    id: minpresence2
    optimistic: true
    unit_of_measurement: cm
    min_value: 30
    max_value: 425
    step: 1
  - platform: template
    name: "Max Presence Distance2"
    id: maxpresence2
    optimistic: true
    unit_of_measurement: cm
    min_value: 30
    max_value: 425
    step: 1
  - platform: template
    name: "Unoccupied Time2"
    id: unocc_time2
    optimistic: true
    unit_of_measurement: sec
    min_value: 0
    max_value: 6553
    step: 1

binary_sensor:
  - platform: template
    id: presence_template
    name: "Presence"
    device_class: occupancy
    filters:
      - delayed_off: 5s
  - platform: template
    id: motion_template
    name: "Motion"
    device_class: motion
    filters:
      - delayed_off: 5s
  
  - platform: template
    id: presence_template2
    name: "Presence2"
    device_class: occupancy
    filters:
      - delayed_off: 5s
  - platform: template
    id: motion_template2
    name: "Motion2"
    device_class: motion
    filters:
      - delayed_off: 5s




button:
  - platform: safe_mode
    name: "Restart (Safe Mode)"

  - platform: restart
    name: "Restart ESP"
    entity_category: diagnostic
    on_press:
      - uart.write:
          id: uart_bus
          data: "resetSystem 0"
      - uart.write:
          id: uart_bus2
          data: "resetSystem 0"
  
  - platform: template
    name: "Reboot Module2"
    id: reboot_module2
    entity_category: diagnostic
    on_press:
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xA3, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]

  - platform: template
    name: "Reboot Module"
    id: reboot_module
    entity_category: diagnostic
    on_press:
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xA3, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      
    
  - platform: template
    name: "Factory Reset2"
    id: reset_module2
    entity_category: diagnostic
    on_press:
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xA2, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]

  - platform: template
    name: "Factory Reset"
    id: reset_module
    entity_category: diagnostic
    on_press:
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xA2, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]


  - platform: template
    name: "Set Parameter2"
    id: param_set2
    entity_category: diagnostic
    on_press:
      - script.execute: statepublish2
  
  - platform: template
    name: "Set Parameter"
    id: param_set
    entity_category: diagnostic
    on_press:
      - script.execute: statepublish

switch:
  - platform: template
    name: "Bluetooth"
    id: human_switch
    optimistic: true
    restore_mode: "RESTORE_DEFAULT_ON"
    turn_on_action:
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xA4, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xA3, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
    turn_off_action:
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xA4, 0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xA3, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]


  - platform: template
    name: "Bluetooth2"
    id: human_switch2
    optimistic: true
    restore_mode: "RESTORE_DEFAULT_ON"
    turn_on_action:
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xA4, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xA3, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
    turn_off_action:
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xA4, 0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x02, 0x00, 0xA3, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]


script:
  - id: statepublish
    then:
      - uart.write: 
          id: uart_bus
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus 
          data: !lambda
                  int minmot = id(minmotion).state;
                  int maxmot = id(maxmotion).state;
                  int minpr = id(minpresence).state;
                  int maxpr = id(maxpresence).state;
                  int unocctm = id(unocc_time).state;
                  uint16_t minmvalue = static_cast<uint16_t>(minmot);
                  uint8_t minmhighByte = static_cast<uint8_t>(minmvalue >> 8);
                  uint8_t minmlowByte = static_cast<uint8_t>(minmvalue & 0xFF);
                  uint16_t maxmvalue = static_cast<uint16_t>(maxmot);
                  uint8_t maxmhighByte = static_cast<uint8_t>(maxmvalue >> 8);
                  uint8_t maxmlowByte = static_cast<uint8_t>(maxmvalue & 0xFF);
                  uint16_t minpvalue = static_cast<uint16_t>(minpr);
                  uint8_t minphighByte = static_cast<uint8_t>(minpvalue >> 8);
                  uint8_t minplowByte = static_cast<uint8_t>(minpvalue & 0xFF);
                  uint16_t maxpvalue = static_cast<uint16_t>(maxpr);
                  uint8_t maxphighByte = static_cast<uint8_t>(maxpvalue >> 8);
                  uint8_t maxplowByte = static_cast<uint8_t>(maxpvalue & 0xFF);
                  uint16_t unoccvalue = static_cast<uint16_t>(unocctm * 10);
                  uint8_t unocchighByte = static_cast<uint8_t>(unoccvalue >> 8);
                  uint8_t unocclowByte = static_cast<uint8_t>(unoccvalue & 0xFF);
                  std::vector<uint8_t> data = {0xFD, 0xFC, 0xFB, 0xFA, 0x20, 0x00, 0x67, 0x00, 0x00, 0x00, maxmlowByte, maxmhighByte, 0x00, 0x00, 0x01, 0x00, minmlowByte, minmhighByte, 0x00, 0x00, 0x02, 0x00, maxplowByte, maxphighByte, 0x00, 0x00, 0x03, 0x00, minplowByte, minphighByte, 0x00, 0x00, 0x04, 0x00, unocclowByte, unocchighByte, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01};
                  return data;
      - uart.write:
          id: uart_bus 
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]





  - id: statepublish2
    then:
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFF, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]
      - uart.write:
          id: uart_bus2
          data: !lambda
                  int minmot = id(minmotion2).state;
                  int maxmot = id(maxmotion2).state;
                  int minpr = id(minpresence2).state;
                  int maxpr = id(maxpresence2).state;
                  int unocctm = id(unocc_time2).state;
                  uint16_t minmvalue = static_cast<uint16_t>(minmot);
                  uint8_t minmhighByte = static_cast<uint8_t>(minmvalue >> 8);
                  uint8_t minmlowByte = static_cast<uint8_t>(minmvalue & 0xFF);
                  uint16_t maxmvalue = static_cast<uint16_t>(maxmot);
                  uint8_t maxmhighByte = static_cast<uint8_t>(maxmvalue >> 8);
                  uint8_t maxmlowByte = static_cast<uint8_t>(maxmvalue & 0xFF);
                  uint16_t minpvalue = static_cast<uint16_t>(minpr);
                  uint8_t minphighByte = static_cast<uint8_t>(minpvalue >> 8);
                  uint8_t minplowByte = static_cast<uint8_t>(minpvalue & 0xFF);
                  uint16_t maxpvalue = static_cast<uint16_t>(maxpr);
                  uint8_t maxphighByte = static_cast<uint8_t>(maxpvalue >> 8);
                  uint8_t maxplowByte = static_cast<uint8_t>(maxpvalue & 0xFF);
                  uint16_t unoccvalue = static_cast<uint16_t>(unocctm * 10);
                  uint8_t unocchighByte = static_cast<uint8_t>(unoccvalue >> 8);
                  uint8_t unocclowByte = static_cast<uint8_t>(unoccvalue & 0xFF);
                  std::vector<uint8_t> data = {0xFD, 0xFC, 0xFB, 0xFA, 0x20, 0x00, 0x67, 0x00, 0x00, 0x00, maxmlowByte, maxmhighByte, 0x00, 0x00, 0x01, 0x00, minmlowByte, minmhighByte, 0x00, 0x00, 0x02, 0x00, maxplowByte, maxphighByte, 0x00, 0x00, 0x03, 0x00, minplowByte, minphighByte, 0x00, 0x00, 0x04, 0x00, unocclowByte, unocchighByte, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01};
                  return data;
      - uart.write:
          id: uart_bus2
          data: [0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00, 0xFE, 0x00, 0x01, 0x00, 0x04, 0x03, 0x02, 0x01]




